/* automatically generated by rust-bindgen */

pub const RAFT_NOMEM: ::libc::c_int = 1;
pub const RAFT_BADID: ::libc::c_uint = 2;
pub const RAFT_DUPLICATEID: ::libc::c_uint = 3;
pub const RAFT_DUPLICATEADDRESS: ::libc::c_uint = 4;
pub const RAFT_BADROLE: ::libc::c_uint = 5;
pub const RAFT_MALFORMED: ::libc::c_int = 6;
pub const RAFT_NOTLEADER: ::libc::c_uint = 7;
pub const RAFT_LEADERSHIPLOST: ::libc::c_uint = 8;
pub const RAFT_SHUTDOWN: ::libc::c_uint = 9;
pub const RAFT_CANTBOOTSTRAP: ::libc::c_int = 10;
pub const RAFT_CANTCHANGE: ::libc::c_uint = 11;
pub const RAFT_CORRUPT: ::libc::c_uint = 12;
pub const RAFT_CANCELED: ::libc::c_uint = 13;
pub const RAFT_NAMETOOLONG: ::libc::c_uint = 14;
pub const RAFT_TOOBIG: ::libc::c_uint = 15;
pub const RAFT_NOCONNECTION: ::libc::c_uint = 16;
pub const RAFT_BUSY: ::libc::c_uint = 17;
pub const RAFT_IOERR: ::libc::c_uint = 18;
pub const RAFT_NOTFOUND: ::libc::c_uint = 19;
pub const RAFT_INVALID: ::libc::c_uint = 20;
pub const RAFT_UNAUTHORIZED: ::libc::c_uint = 21;
pub const RAFT_NOSPACE: ::libc::c_uint = 22;
pub const RAFT_TOOMANY: ::libc::c_uint = 23;
pub const RAFT_ERRMSG_BUF_SIZE: ::libc::c_uint = 256;
pub const RAFT_STANDBY: ::libc::c_int = 0;
pub const RAFT_VOTER: ::libc::c_int = 1;
pub const RAFT_SPARE: ::libc::c_int = 2;
pub const RAFT_FIXTURE_MAX_SERVERS: ::libc::c_uint = 8;
pub type __darwin_natural_t = ::libc::c_uint;
pub type __darwin_ssize_t = ::libc::c_long;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void)>,
    pub __arg: *mut ::libc::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char; 56usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char; 192usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::libc::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::libc::c_char; 8176usize],
}
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
extern "C" {
    #[doc = " Return the error message describing the given error code."]
    pub fn raft_strerror(errnum: ::libc::c_int) -> *const ::libc::c_char;
}
pub type raft_id = ::libc::c_ulonglong;
#[doc = " Hold the value of a raft term. Guaranteed to be at least 64-bit long."]
pub type raft_term = ::libc::c_ulonglong;
#[doc = " Hold the value of a raft entry index. Guaranteed to be at least 64-bit long."]
pub type raft_index = ::libc::c_ulonglong;
#[doc = " Hold a time value expressed in milliseconds since the epoch."]
pub type raft_time = ::libc::c_ulonglong;
#[doc = " A data buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_buffer {
    pub base: *mut ::libc::c_void,
    pub len: usize,
}
#[doc = " Hold information about a single server in the cluster configuration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_server {
    pub id: raft_id,
    pub address: *mut ::libc::c_char,
    pub role: ::libc::c_int,
}
#[doc = " Hold information about all servers currently part of the cluster."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_configuration {
    pub servers: *mut raft_server,
    pub n: ::libc::c_uint,
}
extern "C" {
    #[doc = " Initialize an empty raft configuration."]
    pub fn raft_configuration_init(c: *mut raft_configuration);
}
extern "C" {
    #[doc = " Release all memory used by the given configuration object."]
    pub fn raft_configuration_close(c: *mut raft_configuration);
}
extern "C" {
    #[doc = " Add a server to a raft configuration."]
    #[doc = ""]
    #[doc = " The @id must be greater than zero and @address point to a valid string."]
    #[doc = ""]
    #[doc = " The @role must be either #RAFT_VOTER, #RAFT_STANDBY, #RAFT_SPARE."]
    #[doc = ""]
    #[doc = " If @id or @address are already in use by another server in the configuration,"]
    #[doc = " an error is returned."]
    #[doc = ""]
    #[doc = " The @address string will be copied and can be released after this function"]
    #[doc = " returns."]
    pub fn raft_configuration_add(
        c: *mut raft_configuration,
        id: raft_id,
        address: *const ::libc::c_char,
        role: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Encode the given configuration object."]
    #[doc = ""]
    #[doc = " The memory of the returned buffer is allocated using raft_malloc(), and"]
    #[doc = " client code is responsible for releasing it when no longer needed."]
    pub fn raft_configuration_encode(
        c: *const raft_configuration,
        buf: *mut raft_buffer,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Hash function which outputs a 64-bit value based on a text and a number."]
    #[doc = ""]
    #[doc = " This can be used to generate a unique ID for a new server being added, for"]
    #[doc = " example based on its address and on the current time in milliseconds since"]
    #[doc = " the Epoch."]
    #[doc = ""]
    #[doc = " It's internally implemented as a SHA1 where only the last 8 bytes of the hash"]
    #[doc = " value are kept."]
    pub fn raft_digest(text: *const ::libc::c_char, n: ::libc::c_ulonglong) -> ::libc::c_ulonglong;
}
pub const RAFT_COMMAND: _bindgen_ty_1 = 1;
pub const RAFT_BARRIER: _bindgen_ty_1 = 2;
pub const RAFT_CHANGE: _bindgen_ty_1 = 3;
#[doc = " Log entry types."]
pub type _bindgen_ty_1 = u32;
#[doc = " A single entry in the raft log."]
#[doc = ""]
#[doc = " An entry that originated from this raft instance while it was the leader"]
#[doc = " (typically via client calls to raft_apply()) should normally have a @buf"]
#[doc = " attribute referencing directly the memory that was originally allocated by"]
#[doc = " the client itself to contain the entry data, and the @batch attribute set to"]
#[doc = " #NULL."]
#[doc = ""]
#[doc = " An entry that was received from the network as part of an AppendEntries RPC"]
#[doc = " or that was loaded from disk at startup should normally have a @batch"]
#[doc = " attribute that points to a contiguous chunk of memory that contains the data"]
#[doc = " of the entry itself plus possibly the data for other entries that were"]
#[doc = " received or loaded with it at the same time. In this case the @buf pointer"]
#[doc = " will be equal to the @batch pointer plus an offset, that locates the position"]
#[doc = " of the entry's data within the batch."]
#[doc = ""]
#[doc = " When the @batch attribute is not #NULL the raft library will take care of"]
#[doc = " releasing that memory only once there are no more references to the"]
#[doc = " associated entries."]
#[doc = ""]
#[doc = " This arrangement makes it possible to minimize the amount of memory-copying"]
#[doc = " when performing I/O."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_entry {
    pub term: raft_term,
    pub type_: ::libc::c_ushort,
    pub buf: raft_buffer,
    pub batch: *mut ::libc::c_void,
}
#[doc = " Counter for outstanding references to a log entry."]
#[doc = ""]
#[doc = " When an entry is first appended to the log, its refcount is set to one (the"]
#[doc = " log itself is the only one referencing the entry). Whenever an entry is"]
#[doc = " included in an I/O request (to write it to disk or to send it to other"]
#[doc = " servers) its refcount is increased by one. Whenever an entry gets deleted"]
#[doc = " from the log its refcount is decreased by one. Likewise, whenever an I/O"]
#[doc = " request is completed the refcount of the relevant entries is decreased by"]
#[doc = " one. When the refcount drops to zero the memory that its @buf attribute"]
#[doc = " points to gets released, or, if the @batch attribute is non-NULL, a check is"]
#[doc = " made to see if all other entries of the same batch also have a zero refcount,"]
#[doc = " and the memory that @batch points to gets released if that's the case."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_entry_ref {
    pub term: raft_term,
    pub index: raft_index,
    pub count: ::libc::c_ushort,
    pub next: *mut raft_entry_ref,
}
#[doc = " In-memory cache of the persistent raft log stored on disk."]
#[doc = ""]
#[doc = " The raft log cache is implemented as a circular buffer of log entries, which"]
#[doc = " makes some frequent operations very efficient (e.g. deleting the first N"]
#[doc = " entries when snapshotting)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_log {
    pub entries: *mut raft_entry,
    pub size: usize,
    pub front: usize,
    pub back: usize,
    pub offset: raft_index,
    pub refs: *mut raft_entry_ref,
    pub refs_size: usize,
    pub snapshot: raft_log__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_log__bindgen_ty_1 {
    pub last_index: raft_index,
    pub last_term: raft_term,
}
#[doc = " Hold the arguments of a RequestVote RPC."]
#[doc = ""]
#[doc = " The RequestVote RPC is invoked by candidates to gather votes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_request_vote {
    pub term: raft_term,
    pub candidate_id: raft_id,
    pub last_log_index: raft_index,
    pub last_log_term: raft_index,
    pub disrupt_leader: bool,
}
#[doc = " Hold the result of a RequestVote RPC."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_request_vote_result {
    pub term: raft_term,
    pub vote_granted: bool,
}
#[doc = " Hold the arguments of an AppendEntries RPC."]
#[doc = ""]
#[doc = " The AppendEntries RPC is invoked by the leader to replicate log entries. It's"]
#[doc = " also used as heartbeat (figure 3.1)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_append_entries {
    pub term: raft_term,
    pub prev_log_index: raft_index,
    pub prev_log_term: raft_term,
    pub leader_commit: raft_index,
    pub entries: *mut raft_entry,
    pub n_entries: ::libc::c_uint,
}
#[doc = " Hold the result of an AppendEntries RPC (figure 3.1)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_append_entries_result {
    pub term: raft_term,
    pub rejected: raft_index,
    pub last_log_index: raft_index,
}
#[doc = " Hold the arguments of an InstallSnapshot RPC (figure 5.3)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_install_snapshot {
    pub term: raft_term,
    pub last_index: raft_index,
    pub last_term: raft_term,
    pub conf: raft_configuration,
    pub conf_index: raft_index,
    pub data: raft_buffer,
}
#[doc = " Hold the arguments of a TimeoutNow RPC."]
#[doc = ""]
#[doc = " The TimeoutNow RPC is invoked by leaders to transfer leadership to a"]
#[doc = " follower."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_timeout_now {
    pub term: raft_term,
    pub last_log_index: raft_index,
    pub last_log_term: raft_index,
}
pub const RAFT_IO_APPEND_ENTRIES: _bindgen_ty_2 = 1;
pub const RAFT_IO_APPEND_ENTRIES_RESULT: _bindgen_ty_2 = 2;
pub const RAFT_IO_REQUEST_VOTE: _bindgen_ty_2 = 3;
pub const RAFT_IO_REQUEST_VOTE_RESULT: _bindgen_ty_2 = 4;
pub const RAFT_IO_INSTALL_SNAPSHOT: _bindgen_ty_2 = 5;
pub const RAFT_IO_TIMEOUT_NOW: _bindgen_ty_2 = 6;
#[doc = " Type codes for RPC messages."]
pub type _bindgen_ty_2 = u32;
#[doc = " A single RPC message that can be sent or received over the network."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct raft_message {
    pub type_: ::libc::c_ushort,
    pub server_id: raft_id,
    pub server_address: *const ::libc::c_char,
    pub __bindgen_anon_1: raft_message__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union raft_message__bindgen_ty_1 {
    pub request_vote: raft_request_vote,
    pub request_vote_result: raft_request_vote_result,
    pub append_entries: raft_append_entries,
    pub append_entries_result: raft_append_entries_result,
    pub install_snapshot: raft_install_snapshot,
    pub timeout_now: raft_timeout_now,
    _bindgen_union_align: [u64; 8usize],
}
#[doc = " Hold the details of a snapshot."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_snapshot {
    pub index: raft_index,
    pub term: raft_term,
    pub configuration: raft_configuration,
    pub configuration_index: raft_index,
    pub bufs: *mut raft_buffer,
    pub n_bufs: ::libc::c_uint,
}
pub type raft_io_send_cb =
    ::std::option::Option<unsafe extern "C" fn(req: *mut raft_io_send, status: ::libc::c_int)>;
#[doc = " Asynchronous request to send an RPC message."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_io_send {
    pub data: *mut ::libc::c_void,
    pub cb: raft_io_send_cb,
}
pub type raft_io_append_cb =
    ::std::option::Option<unsafe extern "C" fn(req: *mut raft_io_append, status: ::libc::c_int)>;
#[doc = " Asynchronous request to store new log entries."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_io_append {
    pub data: *mut ::libc::c_void,
    pub cb: raft_io_append_cb,
}
pub type raft_io_snapshot_put_cb = ::std::option::Option<
    unsafe extern "C" fn(req: *mut raft_io_snapshot_put, status: ::libc::c_int),
>;
#[doc = " Asynchronous request to store a new snapshot."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_io_snapshot_put {
    pub data: *mut ::libc::c_void,
    pub cb: raft_io_snapshot_put_cb,
}
pub type raft_io_snapshot_get_cb = ::std::option::Option<
    unsafe extern "C" fn(
        req: *mut raft_io_snapshot_get,
        snapshot: *mut raft_snapshot,
        status: ::libc::c_int,
    ),
>;
#[doc = " Asynchronous request to load the most recent snapshot available."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_io_snapshot_get {
    pub data: *mut ::libc::c_void,
    pub cb: raft_io_snapshot_get_cb,
}
#[doc = " Customizable tracer, for debugging purposes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_tracer {
    #[doc = " Implementation-defined state object."]
    pub impl_: *mut ::libc::c_void,
    #[doc = " Emit the given trace message, possibly decorating it with the provided"]
    #[doc = " metadata."]
    pub emit: ::std::option::Option<
        unsafe extern "C" fn(
            t: *mut raft_tracer,
            file: *const ::libc::c_char,
            line: ::libc::c_int,
            message: *const ::libc::c_char,
        ),
    >,
}
#[doc = " Callback invoked by the I/O implementation at regular intervals."]
pub type raft_io_tick_cb = ::std::option::Option<unsafe extern "C" fn(io: *mut raft_io)>;
#[doc = " Callback invoked by the I/O implementation when an RPC message is received."]
pub type raft_io_recv_cb =
    ::std::option::Option<unsafe extern "C" fn(io: *mut raft_io, msg: *mut raft_message)>;
pub type raft_io_close_cb = ::std::option::Option<unsafe extern "C" fn(io: *mut raft_io)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct raft_io {
    pub version: ::libc::c_int,
    pub data: *mut ::libc::c_void,
    pub impl_: *mut ::libc::c_void,
    pub errmsg: [::libc::c_char; 256usize],
    pub init: ::std::option::Option<
        unsafe extern "C" fn(
            io: *mut raft_io,
            id: raft_id,
            address: *const ::libc::c_char,
        ) -> ::libc::c_int,
    >,
    pub close: ::std::option::Option<unsafe extern "C" fn(io: *mut raft_io, cb: raft_io_close_cb)>,
    pub load: ::std::option::Option<
        unsafe extern "C" fn(
            io: *mut raft_io,
            term: *mut raft_term,
            voted_for: *mut raft_id,
            snapshot: *mut *mut raft_snapshot,
            start_index: *mut raft_index,
            entries: *mut *mut raft_entry,
            n_entries: *mut usize,
        ) -> ::libc::c_int,
    >,
    pub start: ::std::option::Option<
        unsafe extern "C" fn(
            io: *mut raft_io,
            msecs: ::libc::c_uint,
            tick: raft_io_tick_cb,
            recv: raft_io_recv_cb,
        ) -> ::libc::c_int,
    >,
    pub bootstrap: ::std::option::Option<
        unsafe extern "C" fn(io: *mut raft_io, conf: *const raft_configuration) -> ::libc::c_int,
    >,
    pub recover: ::std::option::Option<
        unsafe extern "C" fn(io: *mut raft_io, conf: *const raft_configuration) -> ::libc::c_int,
    >,
    pub set_term: ::std::option::Option<
        unsafe extern "C" fn(io: *mut raft_io, term: raft_term) -> ::libc::c_int,
    >,
    pub set_vote: ::std::option::Option<
        unsafe extern "C" fn(io: *mut raft_io, server_id: raft_id) -> ::libc::c_int,
    >,
    pub send: ::std::option::Option<
        unsafe extern "C" fn(
            io: *mut raft_io,
            req: *mut raft_io_send,
            message: *const raft_message,
            cb: raft_io_send_cb,
        ) -> ::libc::c_int,
    >,
    pub append: ::std::option::Option<
        unsafe extern "C" fn(
            io: *mut raft_io,
            req: *mut raft_io_append,
            entries: *const raft_entry,
            n: ::libc::c_uint,
            cb: raft_io_append_cb,
        ) -> ::libc::c_int,
    >,
    pub truncate: ::std::option::Option<
        unsafe extern "C" fn(io: *mut raft_io, index: raft_index) -> ::libc::c_int,
    >,
    pub snapshot_put: ::std::option::Option<
        unsafe extern "C" fn(
            io: *mut raft_io,
            trailing: ::libc::c_uint,
            req: *mut raft_io_snapshot_put,
            snapshot: *const raft_snapshot,
            cb: raft_io_snapshot_put_cb,
        ) -> ::libc::c_int,
    >,
    pub snapshot_get: ::std::option::Option<
        unsafe extern "C" fn(
            io: *mut raft_io,
            req: *mut raft_io_snapshot_get,
            cb: raft_io_snapshot_get_cb,
        ) -> ::libc::c_int,
    >,
    pub time: ::std::option::Option<unsafe extern "C" fn(io: *mut raft_io) -> raft_time>,
    pub random: ::std::option::Option<
        unsafe extern "C" fn(
            io: *mut raft_io,
            min: ::libc::c_int,
            max: ::libc::c_int,
        ) -> ::libc::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_fsm {
    pub version: ::libc::c_int,
    pub data: *mut ::libc::c_void,
    pub apply: ::std::option::Option<
        unsafe extern "C" fn(
            fsm: *mut raft_fsm,
            buf: *const raft_buffer,
            result: *mut *mut ::libc::c_void,
        ) -> ::libc::c_int,
    >,
    pub snapshot: ::std::option::Option<
        unsafe extern "C" fn(
            fsm: *mut raft_fsm,
            bufs: *mut *mut raft_buffer,
            n_bufs: *mut ::libc::c_uint,
        ) -> ::libc::c_int,
    >,
    pub restore: ::std::option::Option<
        unsafe extern "C" fn(fsm: *mut raft_fsm, buf: *mut raft_buffer) -> ::libc::c_int,
    >,
}
pub const RAFT_UNAVAILABLE: _bindgen_ty_3 = 0;
pub const RAFT_FOLLOWER: _bindgen_ty_3 = 1;
pub const RAFT_CANDIDATE: _bindgen_ty_3 = 2;
pub const RAFT_LEADER: _bindgen_ty_3 = 3;
#[doc = " State codes."]
pub type _bindgen_ty_3 = u32;
#[doc = " Used by leaders to keep track of replication progress for each server."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_progress {
    pub state: ::libc::c_ushort,
    pub next_index: raft_index,
    pub match_index: raft_index,
    pub snapshot_index: raft_index,
    pub last_send: raft_time,
    pub recent_recv: bool,
}
#[doc = " Close callback."]
#[doc = ""]
#[doc = " It's safe to release the memory of a raft instance only after this callback"]
#[doc = " has fired."]
pub type raft_close_cb = ::std::option::Option<unsafe extern "C" fn(raft: *mut raft)>;
#[doc = " Hold and drive the state of a single raft server in a cluster."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct raft {
    pub data: *mut ::libc::c_void,
    pub tracer: *mut raft_tracer,
    pub io: *mut raft_io,
    pub fsm: *mut raft_fsm,
    pub id: raft_id,
    pub address: *mut ::libc::c_char,
    pub current_term: raft_term,
    pub voted_for: raft_id,
    pub log: raft_log,
    pub configuration: raft_configuration,
    pub configuration_index: raft_index,
    pub configuration_uncommitted_index: raft_index,
    pub election_timeout: ::libc::c_uint,
    pub heartbeat_timeout: ::libc::c_uint,
    pub commit_index: raft_index,
    pub last_applied: raft_index,
    pub last_stored: raft_index,
    pub state: ::libc::c_ushort,
    pub __bindgen_anon_1: raft__bindgen_ty_1,
    pub election_timer_start: raft_time,
    pub transfer: *mut raft_transfer,
    pub snapshot: raft__bindgen_ty_2,
    pub close_cb: raft_close_cb,
    pub errmsg: [::libc::c_char; 256usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union raft__bindgen_ty_1 {
    pub follower_state: raft__bindgen_ty_1__bindgen_ty_1,
    pub candidate_state: raft__bindgen_ty_1__bindgen_ty_2,
    pub leader_state: raft__bindgen_ty_1__bindgen_ty_3,
    _bindgen_union_align: [u64; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft__bindgen_ty_1__bindgen_ty_1 {
    pub randomized_election_timeout: ::libc::c_uint,
    pub current_leader: raft__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub id: raft_id,
    pub address: *mut ::libc::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft__bindgen_ty_1__bindgen_ty_2 {
    pub randomized_election_timeout: ::libc::c_uint,
    pub votes: *mut bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft__bindgen_ty_1__bindgen_ty_3 {
    pub progress: *mut raft_progress,
    pub change: *mut raft_change,
    pub promotee_id: raft_id,
    pub round_number: ::libc::c_ushort,
    pub round_index: raft_index,
    pub round_start: raft_time,
    pub requests: [*mut ::libc::c_void; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft__bindgen_ty_2 {
    pub threshold: ::libc::c_uint,
    pub trailing: ::libc::c_uint,
    pub pending: raft_snapshot,
    pub put: raft_io_snapshot_put,
}
extern "C" {
    pub fn raft_init(
        r: *mut raft,
        io: *mut raft_io,
        fsm: *mut raft_fsm,
        id: raft_id,
        address: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn raft_close(r: *mut raft, cb: raft_close_cb);
}
extern "C" {
    #[doc = " Bootstrap this raft instance using the given configuration. The instance must"]
    #[doc = " not have been started yet and must be completely pristine, otherwise"]
    #[doc = " #RAFT_CANTBOOTSTRAP will be returned."]
    pub fn raft_bootstrap(r: *mut raft, conf: *const raft_configuration) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Force a new configuration in order to recover from a loss of quorum where the"]
    #[doc = " current configuration cannot be restored, such as when a majority of servers"]
    #[doc = " die at the same time."]
    #[doc = ""]
    #[doc = " This works by appending the new configuration directly to the log stored on"]
    #[doc = " disk."]
    #[doc = ""]
    #[doc = " In order for this operation to be safe you must follow these steps:"]
    #[doc = ""]
    #[doc = " 1. Make sure that no servers in the cluster are running, either because they"]
    #[doc = "    died or because you manually stopped them."]
    #[doc = ""]
    #[doc = " 2. Run @raft_recover exactly one time, on the non-dead server which has"]
    #[doc = "    the highest term and the longest log."]
    #[doc = ""]
    #[doc = " 3. Copy the data directory of the server you ran @raft_recover on to all"]
    #[doc = "    other non-dead servers in the cluster, replacing their current data"]
    #[doc = "    directory."]
    #[doc = ""]
    #[doc = " 4. Restart all servers."]
    pub fn raft_recover(r: *mut raft, conf: *const raft_configuration) -> ::libc::c_int;
}
extern "C" {
    pub fn raft_start(r: *mut raft) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Set the election timeout."]
    #[doc = ""]
    #[doc = " Every raft instance is initialized with a default election timeout of 1000"]
    #[doc = " milliseconds. If you wish to tweak it, call this function before starting"]
    #[doc = " your event loop."]
    #[doc = ""]
    #[doc = " From Chapter 9:"]
    #[doc = ""]
    #[doc = "   We recommend a range that is 10-20 times the one-way network latency, which"]
    #[doc = "   keeps split votes rates under 40% in all cases for reasonably sized"]
    #[doc = "   clusters, and typically results in much lower rates."]
    #[doc = ""]
    #[doc = " Note that the current random election timer will be reset and a new one timer"]
    #[doc = " will be generated."]
    pub fn raft_set_election_timeout(r: *mut raft, msecs: ::libc::c_uint);
}
extern "C" {
    #[doc = " Set the heartbeat timeout."]
    pub fn raft_set_heartbeat_timeout(r: *mut raft, msecs: ::libc::c_uint);
}
extern "C" {
    #[doc = " Number of outstanding log entries before starting a new snapshot. The default"]
    #[doc = " is 1024."]
    pub fn raft_set_snapshot_threshold(r: *mut raft, n: ::libc::c_uint);
}
extern "C" {
    #[doc = " Number of outstanding log entries to keep in the log after a snapshot has"]
    #[doc = " been taken. This avoids sending snapshots when a follower is behind by just a"]
    #[doc = " few entries. The default is 128."]
    pub fn raft_set_snapshot_trailing(r: *mut raft, n: ::libc::c_uint);
}
extern "C" {
    #[doc = " Return a human-readable description of the last error occured."]
    pub fn raft_errmsg(r: *mut raft) -> *const ::libc::c_char;
}
extern "C" {
    #[doc = " Return the code of the current raft state."]
    pub fn raft_state(r: *mut raft) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Return the ID and address of the current known leader, if any."]
    pub fn raft_leader(r: *mut raft, id: *mut raft_id, address: *mut *const ::libc::c_char);
}
extern "C" {
    #[doc = " Return the index of the last entry that was appended to the local log."]
    pub fn raft_last_index(r: *mut raft) -> raft_index;
}
extern "C" {
    #[doc = " Return the index of the last entry that was applied to the local FSM."]
    pub fn raft_last_applied(r: *mut raft) -> raft_index;
}
pub type raft_apply_cb = ::std::option::Option<
    unsafe extern "C" fn(req: *mut raft_apply, status: ::libc::c_int, result: *mut ::libc::c_void),
>;
#[doc = " Asynchronous request to append a new command entry to the log and apply it to"]
#[doc = " the FSM when a quorum is reached."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_apply {
    pub data: *mut ::libc::c_void,
    pub type_: ::libc::c_int,
    pub index: raft_index,
    pub queue: [*mut ::libc::c_void; 2usize],
    pub cb: raft_apply_cb,
}
extern "C" {
    #[doc = " Propose to append commands to the log and apply them to the FSM once"]
    #[doc = " committed."]
    #[doc = ""]
    #[doc = " If this server is the leader, it will create @n new log entries of type"]
    #[doc = " #RAFT_COMMAND using the given buffers as their payloads, append them to its"]
    #[doc = " own log and attempt to replicate them on other servers by sending"]
    #[doc = " AppendEntries RPCs."]
    #[doc = ""]
    #[doc = " The memory pointed at by the @base attribute of each #raft_buffer in the"]
    #[doc = " given array must have been allocated with raft_malloc() or a compatible"]
    #[doc = " allocator. If this function returns 0, the ownership of this memory is"]
    #[doc = " implicitly transferred to the raft library, which will take care of releasing"]
    #[doc = " it when appropriate. Any further client access to such memory leads to"]
    #[doc = " undefined behavior."]
    #[doc = ""]
    #[doc = " The ownership of the memory of the @bufs array itself is not transferred to"]
    #[doc = " the raft library, and, if allocated dynamically, must be deallocated by the"]
    #[doc = " caller."]
    pub fn raft_apply(
        r: *mut raft,
        req: *mut raft_apply,
        bufs: *const raft_buffer,
        n: ::libc::c_uint,
        cb: raft_apply_cb,
    ) -> ::libc::c_int;
}
pub type raft_barrier_cb =
    ::std::option::Option<unsafe extern "C" fn(req: *mut raft_barrier, status: ::libc::c_int)>;
#[doc = " Asynchronous request to append a barrier entry."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_barrier {
    pub data: *mut ::libc::c_void,
    pub type_: ::libc::c_int,
    pub index: raft_index,
    pub queue: [*mut ::libc::c_void; 2usize],
    pub cb: raft_barrier_cb,
}
extern "C" {
    #[doc = " Propose to append a log entry of type #RAFT_BARRIER."]
    #[doc = ""]
    #[doc = " This can be used to ensure that there are no unapplied commands."]
    pub fn raft_barrier(r: *mut raft, req: *mut raft_barrier, cb: raft_barrier_cb)
        -> ::libc::c_int;
}
#[doc = " Asynchronous request to change the raft configuration."]
pub type raft_change_cb =
    ::std::option::Option<unsafe extern "C" fn(req: *mut raft_change, status: ::libc::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_change {
    pub data: *mut ::libc::c_void,
    pub cb: raft_change_cb,
}
extern "C" {
    #[doc = " Add a new server to the cluster configuration. Its initial role will be"]
    #[doc = " #RAFT_SPARE."]
    pub fn raft_add(
        r: *mut raft,
        req: *mut raft_change,
        id: raft_id,
        address: *const ::libc::c_char,
        cb: raft_change_cb,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Assign a new role to the given server."]
    #[doc = ""]
    #[doc = " If the server has already the given role, or if the given role is unknown,"]
    #[doc = " #RAFT_BADROLE is returned."]
    pub fn raft_assign(
        r: *mut raft,
        req: *mut raft_change,
        id: raft_id,
        role: ::libc::c_int,
        cb: raft_change_cb,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Remove the given server from the cluster configuration."]
    pub fn raft_remove(
        r: *mut raft,
        req: *mut raft_change,
        id: raft_id,
        cb: raft_change_cb,
    ) -> ::libc::c_int;
}
#[doc = " Asynchronous request to transfer leadership."]
pub type raft_transfer_cb = ::std::option::Option<unsafe extern "C" fn(req: *mut raft_transfer)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_transfer {
    pub data: *mut ::libc::c_void,
    pub id: raft_id,
    pub start: raft_time,
    pub send: raft_io_send,
    pub cb: raft_transfer_cb,
}
extern "C" {
    #[doc = " Transfer leadership to the server with the given ID."]
    #[doc = ""]
    #[doc = " If the target server is not part of the configuration, or it's the leader"]
    #[doc = " itself, or it's not a #RAFT_VOTER, then #RAFT_BADID is returned."]
    #[doc = ""]
    #[doc = " The special value #0 means to automatically select a voting follower to"]
    #[doc = " transfer leadership to. If there are no voting followers, return"]
    #[doc = " #RAFT_NOTFOUND."]
    #[doc = ""]
    #[doc = " When this server detects that the target server has become the leader, or"]
    #[doc = " when @election_timeout milliseconds have elapsed, the given callback will be"]
    #[doc = " invoked."]
    #[doc = ""]
    #[doc = " After the callback files, clients can check whether the operation was"]
    #[doc = " successful or not by calling @raft_leader() and checking if it returns the"]
    #[doc = " target server."]
    pub fn raft_transfer(
        r: *mut raft,
        req: *mut raft_transfer,
        id: raft_id,
        cb: raft_transfer_cb,
    ) -> ::libc::c_int;
}
#[doc = " User-definable dynamic memory allocation functions."]
#[doc = ""]
#[doc = " The @data field will be passed as first argument to all functions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_heap {
    pub data: *mut ::libc::c_void,
    pub malloc: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::libc::c_void, size: usize) -> *mut ::libc::c_void,
    >,
    pub free: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::libc::c_void, ptr: *mut ::libc::c_void),
    >,
    pub calloc: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::libc::c_void,
            nmemb: usize,
            size: usize,
        ) -> *mut ::libc::c_void,
    >,
    pub realloc: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::libc::c_void,
            ptr: *mut ::libc::c_void,
            size: usize,
        ) -> *mut ::libc::c_void,
    >,
    pub aligned_alloc: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::libc::c_void,
            alignment: usize,
            size: usize,
        ) -> *mut ::libc::c_void,
    >,
}
extern "C" {
    pub fn raft_malloc(size: usize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn raft_free(ptr: *mut ::libc::c_void);
}
extern "C" {
    pub fn raft_calloc(nmemb: usize, size: usize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn raft_realloc(ptr: *mut ::libc::c_void, size: usize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn raft_aligned_alloc(alignment: usize, size: usize) -> *mut ::libc::c_void;
}
extern "C" {
    #[doc = " Use a custom dynamic memory allocator."]
    pub fn raft_heap_set(heap: *mut raft_heap);
}
extern "C" {
    #[doc = " Use the default dynamic memory allocator (from the stdlib). This clears any"]
    #[doc = " custom allocator specified with @raft_heap_set."]
    pub fn raft_heap_set_default();
}
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_t = __darwin_pthread_t;
pub type mach_port_t = __darwin_mach_port_t;
pub type semaphore_t = mach_port_t;
extern "C" {
    #[doc = " Configure the given @raft_io instance to use a libuv-based I/O"]
    #[doc = " implementation."]
    #[doc = ""]
    #[doc = " The @dir path will be copied, and its memory can possibly be released once"]
    #[doc = " this function returns."]
    #[doc = ""]
    #[doc = " Return #RAFT_NAMETOOLONG if @dir exceeds the size of the internal buffer"]
    #[doc = " that should hold it"]
    #[doc = ""]
    #[doc = " Return #RAFT_NOTFOUND if @dir does not exist."]
    #[doc = ""]
    #[doc = " Return #RAFT_INVALID if @dir exists but it's not a directory."]
    #[doc = ""]
    #[doc = " The implementation of metadata and log persistency is virtually the same as"]
    #[doc = " the one found in LogCabin [0]."]
    #[doc = ""]
    #[doc = " The disk files consist of metadata files, closed segments, and open"]
    #[doc = " segments. Metadata files are used to track Raft metadata, such as the"]
    #[doc = " server's current term, vote, and log's start index. Segments contain"]
    #[doc = " contiguous entries that are part of the log. Closed segments are never"]
    #[doc = " written to again (but may be renamed and truncated if a suffix of the log is"]
    #[doc = " truncated). Open segments are where newly appended entries go. Once an open"]
    #[doc = " segment reaches the maximum allowed size, it is closed and a new one is used."]
    #[doc = ""]
    #[doc = " Metadata files are named \"metadata1\" and \"metadata2\". The code alternates"]
    #[doc = " between these so that there is always at least one readable metadata file."]
    #[doc = " On boot, the readable metadata file with the higher version number is used."]
    #[doc = ""]
    #[doc = " The format of a metadata file is:"]
    #[doc = ""]
    #[doc = " [8 bytes] Format (currently 1)."]
    #[doc = " [8 bytes] Incremental version number."]
    #[doc = " [8 bytes] Current term."]
    #[doc = " [8 bytes] ID of server we voted for."]
    #[doc = ""]
    #[doc = " Closed segments are named by the format string \"%lu-%lu\" with their"]
    #[doc = " start and end indexes, both inclusive. Closed segments always contain at"]
    #[doc = " least one entry; the end index is always at least as large as the start"]
    #[doc = " index. Closed segment files may occasionally include data past their"]
    #[doc = " filename's end index (these are ignored but a warning is logged). This can"]
    #[doc = " happen if the suffix of the segment is truncated and a crash occurs at an"]
    #[doc = " inopportune time (the segment file is first renamed, then truncated, and a"]
    #[doc = " crash occurs in between)."]
    #[doc = ""]
    #[doc = " Open segments are named by the format string \"open-%lu\" with a unique"]
    #[doc = " number. These should not exist when the server shuts down cleanly, but they"]
    #[doc = " exist while the server is running and may be left around during a crash."]
    #[doc = " Open segments either contain entries which come after the last closed"]
    #[doc = " segment or are full of zeros. When the server crashes while appending to an"]
    #[doc = " open segment, the end of that file may be corrupt. We can't distinguish"]
    #[doc = " between a corrupt file and a partially written entry. The code assumes it's"]
    #[doc = " a partially written entry, logs a warning, and ignores it."]
    #[doc = ""]
    #[doc = " Truncating a suffix of the log will remove all entries that are no longer"]
    #[doc = " part of the log. Truncating a prefix of the log will only remove complete"]
    #[doc = " segments that are before the new log start index. For example, if a"]
    #[doc = " segment has entries 10 through 20 and the prefix of the log is truncated to"]
    #[doc = " start at entry 15, that entire segment will be retained."]
    #[doc = ""]
    #[doc = " Each segment file starts with a segment header, which currently contains"]
    #[doc = " just an 8-byte version number for the format of that segment. The current"]
    #[doc = " format (version 1) is just a concatenation of serialized entry batches."]
    #[doc = ""]
    #[doc = " Each batch has the following format:"]
    #[doc = ""]
    #[doc = " [4 bytes] CRC32 checksum of the batch header, little endian."]
    #[doc = " [4 bytes] CRC32 checksum of the batch data, little endian."]
    #[doc = " [  ...  ] Batch (as described in @raft_decode_entries_batch)."]
    #[doc = ""]
    #[doc = " [0] https://github.com/logcabin/logcabin/blob/master/Storage/SegmentedLog.h"]
    pub fn raft_uv_init(
        io: *mut raft_io,
        loop_: *mut uv_loop_s,
        dir: *const ::libc::c_char,
        transport: *mut raft_uv_transport,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Release any memory allocated internally."]
    pub fn raft_uv_close(io: *mut raft_io);
}
extern "C" {
    #[doc = " Set the block size that will be used for direct I/O."]
    #[doc = ""]
    #[doc = " The default is to automatically detect the appropriate block size."]
    pub fn raft_uv_set_block_size(io: *mut raft_io, size: usize);
}
extern "C" {
    #[doc = " Set the maximum initial size of newly created open segments."]
    #[doc = ""]
    #[doc = " If the given size is not a multiple of the block size, the actual size will"]
    #[doc = " be reduced to the closest multiple."]
    #[doc = ""]
    #[doc = " The default is 8 megabytes."]
    pub fn raft_uv_set_segment_size(io: *mut raft_io, size: usize);
}
extern "C" {
    #[doc = " Set how many milliseconds to wait between subsequent retries when"]
    #[doc = " establishing a connection with another server. The default is 1000"]
    #[doc = " milliseconds."]
    pub fn raft_uv_set_connect_retry_delay(io: *mut raft_io, msecs: ::libc::c_uint);
}
extern "C" {
    #[doc = " Emit low-level debug messages using the given tracer."]
    pub fn raft_uv_set_tracer(io: *mut raft_io, tracer: *mut raft_tracer);
}
#[doc = " Callback invoked by the transport implementation when a new incoming"]
#[doc = " connection has been established."]
#[doc = ""]
#[doc = " No references to @address must be kept after this function returns."]
#[doc = ""]
#[doc = " Ownership of @stream is transfered to user code, which is responsible of"]
#[doc = " uv_close()'ing it and then releasing its memory."]
pub type raft_uv_accept_cb = ::std::option::Option<
    unsafe extern "C" fn(
        t: *mut raft_uv_transport,
        id: raft_id,
        address: *const ::libc::c_char,
        stream: *mut uv_stream_s,
    ),
>;
pub type raft_uv_connect_cb = ::std::option::Option<
    unsafe extern "C" fn(
        req: *mut raft_uv_connect,
        stream: *mut uv_stream_s,
        status: ::libc::c_int,
    ),
>;
#[doc = " Callback invoked by the transport implementation after a connect request has"]
#[doc = " completed. If status is #0, then @stream will point to a valid handle, which"]
#[doc = " user code is then responsible to uv_close() and then release."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_uv_connect {
    pub data: *mut ::libc::c_void,
    pub cb: raft_uv_connect_cb,
}
#[doc = " Callback invoked by the transport implementation after a close request is"]
#[doc = " completed."]
pub type raft_uv_transport_close_cb =
    ::std::option::Option<unsafe extern "C" fn(t: *mut raft_uv_transport)>;
#[doc = " Interface to establish outgoing connections to other Raft servers and to"]
#[doc = " accept incoming connections from them."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct raft_uv_transport {
    #[doc = " User defined data."]
    pub data: *mut ::libc::c_void,
    #[doc = " Implementation-defined state."]
    pub impl_: *mut ::libc::c_void,
    #[doc = " Human-readable message providing diagnostic information about the last"]
    #[doc = " error occurred."]
    pub errmsg: [::libc::c_char; 256usize],
    #[doc = " Initialize the transport with the given server's identity."]
    pub init: ::std::option::Option<
        unsafe extern "C" fn(
            t: *mut raft_uv_transport,
            id: raft_id,
            address: *const ::libc::c_char,
        ) -> ::libc::c_int,
    >,
    #[doc = " Start listening for incoming connections."]
    #[doc = ""]
    #[doc = " Once a new connection is accepted, the @cb callback passed in the"]
    #[doc = " initializer must be invoked with the relevant details of the connecting"]
    #[doc = " Raft server."]
    pub listen: ::std::option::Option<
        unsafe extern "C" fn(t: *mut raft_uv_transport, cb: raft_uv_accept_cb) -> ::libc::c_int,
    >,
    #[doc = " Connect to the server with the given ID and address."]
    #[doc = ""]
    #[doc = " The @cb callback must be invoked when the connection has been established"]
    #[doc = " or the connection attempt has failed. The memory pointed by @req can be"]
    #[doc = " released only after @cb has fired."]
    pub connect: ::std::option::Option<
        unsafe extern "C" fn(
            t: *mut raft_uv_transport,
            req: *mut raft_uv_connect,
            id: raft_id,
            address: *const ::libc::c_char,
            cb: raft_uv_connect_cb,
        ) -> ::libc::c_int,
    >,
    #[doc = " Close the transport."]
    #[doc = ""]
    #[doc = " The implementation must:"]
    #[doc = ""]
    #[doc = " - Stop accepting incoming connections. The @cb callback passed to @listen"]
    #[doc = "   must not be invoked anymore."]
    #[doc = ""]
    #[doc = " - Cancel all pending @connect requests."]
    #[doc = ""]
    #[doc = " - Invoke the @cb callback passed to this method once it's safe to release"]
    #[doc = "   the memory of the transport object."]
    pub close: ::std::option::Option<
        unsafe extern "C" fn(t: *mut raft_uv_transport, cb: raft_uv_transport_close_cb),
    >,
}
extern "C" {
    #[doc = " Init a transport interface that uses TCP sockets."]
    pub fn raft_uv_tcp_init(t: *mut raft_uv_transport, loop_: *mut uv_loop_s) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Release any memory allocated internally."]
    pub fn raft_uv_tcp_close(t: *mut raft_uv_transport);
}
pub const RAFT_FIXTURE_TICK: _bindgen_ty_6 = 1;
pub const RAFT_FIXTURE_NETWORK: _bindgen_ty_6 = 2;
pub const RAFT_FIXTURE_DISK: _bindgen_ty_6 = 3;
#[doc = " Fixture step event types."]
pub type _bindgen_ty_6 = u32;
#[doc = " State of a single server in a cluster fixture."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct raft_fixture_server {
    pub alive: bool,
    pub id: raft_id,
    pub address: [::libc::c_char; 16usize],
    pub tracer: raft_tracer,
    pub io: raft_io,
    pub raft: raft,
}
#[doc = " Information about a test cluster event triggered by the fixture."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct raft_fixture_event {
    pub server_index: ::libc::c_uint,
    pub type_: ::libc::c_int,
}
pub type raft_fixture_event_cb = ::std::option::Option<
    unsafe extern "C" fn(f: *mut raft_fixture, event: *mut raft_fixture_event),
>;
#[doc = " Event callback. See raft_fixture_hook()."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct raft_fixture {
    pub time: raft_time,
    pub n: ::libc::c_uint,
    pub leader_id: raft_id,
    pub log: raft_log,
    pub commit_index: raft_index,
    pub event: raft_fixture_event,
    pub hook: raft_fixture_event_cb,
    pub servers: [raft_fixture_server; 8usize],
}
extern "C" {
    #[doc = " Initialize a raft cluster fixture with @n servers. Each server will use an"]
    #[doc = " in-memory @raft_io implementation and one of the given @fsms. All servers"]
    #[doc = " will be initially connected to one another, but they won't be bootstrapped or"]
    #[doc = " started."]
    pub fn raft_fixture_init(
        f: *mut raft_fixture,
        n: ::libc::c_uint,
        fsms: *mut raft_fsm,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Release all memory used by the fixture."]
    pub fn raft_fixture_close(f: *mut raft_fixture);
}
extern "C" {
    #[doc = " Convenience to generate a configuration object containing all servers in the"]
    #[doc = " cluster. The first @n_voting servers will be voting ones."]
    pub fn raft_fixture_configuration(
        f: *mut raft_fixture,
        n_voting: ::libc::c_uint,
        conf: *mut raft_configuration,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Convenience to bootstrap all servers in the cluster using the given"]
    #[doc = " configuration."]
    pub fn raft_fixture_bootstrap(
        f: *mut raft_fixture,
        conf: *mut raft_configuration,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Convenience to start all servers in the fixture."]
    pub fn raft_fixture_start(f: *mut raft_fixture) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Return the number of servers in the fixture."]
    pub fn raft_fixture_n(f: *mut raft_fixture) -> ::libc::c_uint;
}
extern "C" {
    #[doc = " Return the current cluster global time. All raft instances see the same time."]
    pub fn raft_fixture_time(f: *mut raft_fixture) -> raft_time;
}
extern "C" {
    #[doc = " Return the raft instance associated with the @i'th server of the fixture."]
    pub fn raft_fixture_get(f: *mut raft_fixture, i: ::libc::c_uint) -> *mut raft;
}
extern "C" {
    #[doc = " Return @true if the @i'th server hasn't been killed."]
    pub fn raft_fixture_alive(f: *mut raft_fixture, i: ::libc::c_uint) -> bool;
}
extern "C" {
    #[doc = " Return the index of the current leader, or the current number of servers if"]
    #[doc = " there's no leader."]
    pub fn raft_fixture_leader_index(f: *mut raft_fixture) -> ::libc::c_uint;
}
extern "C" {
    #[doc = " Return the ID of the server the @i'th server has voted for, or zero ."]
    pub fn raft_fixture_voted_for(f: *mut raft_fixture, i: ::libc::c_uint) -> raft_id;
}
extern "C" {
    #[doc = " Drive the cluster so the @i'th server gets elected as leader."]
    #[doc = ""]
    #[doc = " This is achieved by bumping the randomized election timeout of all other"]
    #[doc = " servers to a very high value, letting the one of the @i'th server expire and"]
    #[doc = " then stepping the cluster until the election is won."]
    #[doc = ""]
    #[doc = " There must currently be no leader and no candidate and the given server must"]
    #[doc = " be a voting one. Also, the @i'th server must be connected to a majority of"]
    #[doc = " voting servers."]
    pub fn raft_fixture_elect(f: *mut raft_fixture, i: ::libc::c_uint);
}
extern "C" {
    #[doc = " Drive the cluster so the current leader gets deposed."]
    #[doc = ""]
    #[doc = " This is achieved by dropping all AppendEntries result messages sent by"]
    #[doc = " followers to the leader, until the leader decides to step down because it has"]
    #[doc = " lost connectivity to a majority of followers."]
    pub fn raft_fixture_depose(f: *mut raft_fixture);
}
extern "C" {
    #[doc = " Step through the cluster state advancing the time to the minimum value needed"]
    #[doc = " for it to make progress (i.e. for a message to be delivered, for an I/O"]
    #[doc = " operation to complete or for a single time tick to occur)."]
    #[doc = ""]
    #[doc = " In particular, the following happens:"]
    #[doc = ""]
    #[doc = " 1. If there are pending #raft_io_send requests, that have been submitted"]
    #[doc = "    using #raft_io->send() and not yet sent, the oldest one is picked and the"]
    #[doc = "    relevant callback fired. This simulates completion of a socket write,"]
    #[doc = "    which means that the send request has been completed. The receiver does"]
    #[doc = "    not immediately receives the message, as the message is propagating"]
    #[doc = "    through the network. However any memory associated with the #raft_io_send"]
    #[doc = "    request can be released (e.g. log entries). The in-memory I/O"]
    #[doc = "    implementation assigns a latency to each RPC message, which will get"]
    #[doc = "    delivered to the receiver only after that amount of time elapses. If the"]
    #[doc = "    sender and the receiver are currently disconnected, the RPC message is"]
    #[doc = "    simply dropped. If a callback was fired, jump directly to 3. and skip 2."]
    #[doc = ""]
    #[doc = " 2. All pending #raft_io_append disk writes across all servers, that have been"]
    #[doc = "    submitted using #raft_io->append() but not yet completed, are scanned and"]
    #[doc = "    the one with the lowest completion time is picked. All in-flight network"]
    #[doc = "    messages waiting to be delivered are scanned and the one with the lowest"]
    #[doc = "    delivery time is picked. All servers are scanned, and the one with the"]
    #[doc = "    lowest tick expiration time is picked. The three times are compared and"]
    #[doc = "    the lowest one is picked. If a #raft_io_append disk write has completed,"]
    #[doc = "    the relevant callback will be invoked, if there's a network message to be"]
    #[doc = "    delivered, the receiver's @raft_io_recv_cb callback gets fired, if a tick"]
    #[doc = "    timer has expired the relevant #raft_io->tick() callback will be"]
    #[doc = "    invoked. Only one event will be fired. If there is more than one event to"]
    #[doc = "    fire, one of them is picked according to the following rules: events for"]
    #[doc = "    servers with lower index are fired first, tick events take precedence over"]
    #[doc = "    disk events, and disk events take precedence over network events."]
    #[doc = ""]
    #[doc = " 3. The current cluster leader is detected (if any). When detecting the leader"]
    #[doc = "    the Election Safety property is checked: no servers can be in leader state"]
    #[doc = "    for the same term. The server in leader state with the highest term is"]
    #[doc = "    considered the current cluster leader, as long as it's \"stable\", i.e. it"]
    #[doc = "    has been acknowledged by all servers connected to it, and those servers"]
    #[doc = "    form a majority (this means that no further leader change can happen,"]
    #[doc = "    unless the network gets disrupted). If there is a stable leader and it has"]
    #[doc = "    not changed with respect to the previous call to @raft_fixture_step(),"]
    #[doc = "    then the Leader Append-Only property is checked, by comparing its log with"]
    #[doc = "    a copy of it that was taken during the previous iteration."]
    #[doc = ""]
    #[doc = " 4. If there is a stable leader, its current log is copied, in order to be"]
    #[doc = "    able to check the Leader Append-Only property at the next call."]
    #[doc = ""]
    #[doc = " 5. If there is a stable leader, its commit index gets copied."]
    #[doc = ""]
    #[doc = " The function returns information about which particular event occurred"]
    #[doc = " (either in step 1 or 2)."]
    pub fn raft_fixture_step(f: *mut raft_fixture) -> *mut raft_fixture_event;
}
extern "C" {
    #[doc = " Call raft_fixture_step() exactly @n times, and return the last event fired."]
    pub fn raft_fixture_step_n(f: *mut raft_fixture, n: ::libc::c_uint) -> *mut raft_fixture_event;
}
extern "C" {
    #[doc = " Step the cluster until the given @stop function returns #true, or @max_msecs"]
    #[doc = " have elapsed."]
    #[doc = ""]
    #[doc = " Return #true if the @stop function has returned #true within @max_msecs."]
    pub fn raft_fixture_step_until(
        f: *mut raft_fixture,
        stop: ::std::option::Option<
            unsafe extern "C" fn(f: *mut raft_fixture, arg: *mut ::libc::c_void) -> bool,
        >,
        arg: *mut ::libc::c_void,
        max_msecs: ::libc::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " Step the cluster until @msecs have elapsed."]
    pub fn raft_fixture_step_until_elapsed(f: *mut raft_fixture, msecs: ::libc::c_uint);
}
extern "C" {
    #[doc = " Step the cluster until a leader is elected, or @max_msecs have elapsed."]
    pub fn raft_fixture_step_until_has_leader(
        f: *mut raft_fixture,
        max_msecs: ::libc::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " Step the cluster until the current leader gets deposed, or @max_msecs have"]
    #[doc = " elapsed."]
    pub fn raft_fixture_step_until_has_no_leader(
        f: *mut raft_fixture,
        max_msecs: ::libc::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " Step the cluster until the @i'th server has applied the entry at the given"]
    #[doc = " index, or @max_msecs have elapsed. If @i equals the number of servers, then"]
    #[doc = " step until all servers have applied the given entry."]
    pub fn raft_fixture_step_until_applied(
        f: *mut raft_fixture,
        i: ::libc::c_uint,
        index: raft_index,
        max_msecs: ::libc::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " Step the cluster until the state of the @i'th server matches the given one,"]
    #[doc = " or @max_msecs have elapsed."]
    pub fn raft_fixture_step_until_state_is(
        f: *mut raft_fixture,
        i: ::libc::c_uint,
        state: ::libc::c_int,
        max_msecs: ::libc::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " Step the cluster until the term of the @i'th server matches the given one,"]
    #[doc = " or @max_msecs have elapsed."]
    pub fn raft_fixture_step_until_term_is(
        f: *mut raft_fixture,
        i: ::libc::c_uint,
        term: raft_term,
        max_msecs: ::libc::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " Step the cluster until the @i'th server has voted for the @j'th one, or"]
    #[doc = " @max_msecs have elapsed."]
    pub fn raft_fixture_step_until_voted_for(
        f: *mut raft_fixture,
        i: ::libc::c_uint,
        j: ::libc::c_uint,
        max_msecs: ::libc::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " Step the cluster until all pending network messages from the @i'th server to"]
    #[doc = " the @j'th server have been delivered, or @max_msecs have elapsed."]
    pub fn raft_fixture_step_until_delivered(
        f: *mut raft_fixture,
        i: ::libc::c_uint,
        j: ::libc::c_uint,
        max_msecs: ::libc::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " Set a function to be called after every time a fixture event occurs as"]
    #[doc = " consequence of a step."]
    pub fn raft_fixture_hook(f: *mut raft_fixture, hook: raft_fixture_event_cb);
}
extern "C" {
    #[doc = " Disconnect the @i'th and the @j'th servers, so attempts to send a message"]
    #[doc = " from @i to @j will fail with #RAFT_NOCONNECTION."]
    pub fn raft_fixture_disconnect(f: *mut raft_fixture, i: ::libc::c_uint, j: ::libc::c_uint);
}
extern "C" {
    #[doc = " Reconnect the @i'th and the @j'th servers, so attempts to send a message"]
    #[doc = " from @i to @j will succeed again."]
    pub fn raft_fixture_reconnect(f: *mut raft_fixture, i: ::libc::c_uint, j: ::libc::c_uint);
}
extern "C" {
    #[doc = " Saturate the connection between the @i'th and the @j'th servers, so messages"]
    #[doc = " sent by @i to @j will be silently dropped."]
    pub fn raft_fixture_saturate(f: *mut raft_fixture, i: ::libc::c_uint, j: ::libc::c_uint);
}
extern "C" {
    #[doc = " Return true if the connection from the @i'th to the @j'th server has been set"]
    #[doc = " as saturated."]
    pub fn raft_fixture_saturated(
        f: *mut raft_fixture,
        i: ::libc::c_uint,
        j: ::libc::c_uint,
    ) -> bool;
}
extern "C" {
    #[doc = " Desaturate the connection between the @i'th and the @j'th servers, so"]
    #[doc = " messages sent by @i to @j will start being delivered again."]
    pub fn raft_fixture_desaturate(f: *mut raft_fixture, i: ::libc::c_uint, j: ::libc::c_uint);
}
extern "C" {
    #[doc = " Kill the server with the given index. The server won't receive any message"]
    #[doc = " and its tick callback won't be invoked."]
    pub fn raft_fixture_kill(f: *mut raft_fixture, i: ::libc::c_uint);
}
extern "C" {
    #[doc = " Add a new empty server to the cluster and connect it to all others."]
    pub fn raft_fixture_grow(f: *mut raft_fixture, fsm: *mut raft_fsm) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Set the value that will be returned to the @i'th raft instance when it asks"]
    #[doc = " the underlying #raft_io implementation for a randomized election timeout"]
    #[doc = " value. The default value is 1000 + @i * 100, meaning that the election timer"]
    #[doc = " of server 0 will expire first."]
    pub fn raft_fixture_set_randomized_election_timeout(
        f: *mut raft_fixture,
        i: ::libc::c_uint,
        msecs: ::libc::c_uint,
    );
}
extern "C" {
    #[doc = " Set the network latency in milliseconds. Each RPC message sent by the @i'th"]
    #[doc = " server from now on will take @msecs milliseconds to be delivered. The default"]
    #[doc = " value is 15."]
    pub fn raft_fixture_set_network_latency(
        f: *mut raft_fixture,
        i: ::libc::c_uint,
        msecs: ::libc::c_uint,
    );
}
extern "C" {
    #[doc = " Set the disk I/O latency in milliseconds. Each append request will take this"]
    #[doc = " amount of milliseconds to complete. The default value is 10."]
    pub fn raft_fixture_set_disk_latency(
        f: *mut raft_fixture,
        i: ::libc::c_uint,
        msecs: ::libc::c_uint,
    );
}
extern "C" {
    #[doc = " Set the persisted term of the @i'th server."]
    pub fn raft_fixture_set_term(f: *mut raft_fixture, i: ::libc::c_uint, term: raft_term);
}
extern "C" {
    #[doc = " Set the most recent persisted snapshot on the @i'th server."]
    pub fn raft_fixture_set_snapshot(
        f: *mut raft_fixture,
        i: ::libc::c_uint,
        snapshot: *mut raft_snapshot,
    );
}
extern "C" {
    #[doc = " Add an entry to the persisted entries of the @i'th server."]
    pub fn raft_fixture_add_entry(f: *mut raft_fixture, i: ::libc::c_uint, entry: *mut raft_entry);
}
extern "C" {
    #[doc = " Inject an I/O failure that will be triggered on the @i'th server after @delay"]
    #[doc = " I/O requests and occur @repeat times."]
    pub fn raft_fixture_io_fault(
        f: *mut raft_fixture,
        i: ::libc::c_uint,
        delay: ::libc::c_int,
        repeat: ::libc::c_int,
    );
}
extern "C" {
    #[doc = " Return the number of messages of the given type that the @i'th server has"]
    #[doc = " successfully sent so far."]
    pub fn raft_fixture_n_send(
        f: *mut raft_fixture,
        i: ::libc::c_uint,
        type_: ::libc::c_int,
    ) -> ::libc::c_uint;
}
extern "C" {
    #[doc = " Return the number of messages of the given type that the @i'th server has"]
    #[doc = " received so far."]
    pub fn raft_fixture_n_recv(
        f: *mut raft_fixture,
        i: ::libc::c_uint,
        type_: ::libc::c_int,
    ) -> ::libc::c_uint;
}
